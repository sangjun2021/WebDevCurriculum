# CheckList

- ## 형상관리 시스템은 왜 나오게 되었을까요?
    - ### 프로그램을 한번 만들고 끝내는게 아니라 지속적으로 버전을 업그레이드 시켜야하는데 기존에는 파일을 여러개 만들거나 하나의 파일을 최신화 하는 방식을 썼지만 아래와 같은 문제점들이 생기게 되었고 파일은 하나로 유지한 채로 파일의 변경 이력을 추적하고 관리하기 위해서 만들어졌다.
    - ### 형상 관리 시스템을 사용하지 않았을때 발생하는 문제들
        - 파일이 업데이트 될때마다 파일의 이름을 변경해서 따로 별도의 파일을 생성해야 되므로 파일의 이름과 생성과 수정날짜를 일일히 확인하고 괸리해줘야 어떤 파일이 가장 최근이 생긴건지 알 수 있다.
        - 협업을 진행 할 경우 한사람이 파일을 수정하고 다음 사람에게 이메일이나 usb를 통해 전달하고 그 다음사람이 작업하는 직렬적인 작업을 하게 되서 작업 속도가 매우 느려진다.
- ## git은 어떤 형상관리 시스템이고 어떤 특징을 가지고 있을까요? 분산형 형상관리 시스템이란 무엇일까요?
    - ### git은 분산형 형상 관리 시스템이고 분산형 형상 관리 시스템은 서버에만 메인 코드를 저장하는 것이 아니라 작업을 하는 모든 컴퓨터에서 소스코드를 저장하고 있기때문에 서버가 불안정하거나 데이터가 날아가는 경우 중앙집중형 형상 관리 시스템 인 SVN은 복구가 가능하지만 마지막 snapshot만 복구가 가능 하기 때문에 해당 파일의이력까지는 복구 할수 없다. 분산형 형상관리 시스템은 작업중인 아무 컴퓨터를 통해 해당 컴퓨터에 저장되어 있는 최근 snapshot이전의 이력까지 복구할수 있는 장점이 있다.
    - ### git은 어떻게 개발되게 되었을까요? git이 분산형 시스템을 채택한 이유는 무엇일까요?
        - 리눅스를 개발 할 당시 bitkeeper라는 분산형 형상 관리 시스템을 사용 했었는데 오픈 소스를 추구하는 리눅스와 이윤을 추구하는 bitkeeper의 의견 충돌(리눅스 유료화 관련)로 인해 bitkeeper의 무료 사용이 제한 되었기 때문에 리누스 토르발즈가 자체적으로 분산형 형상 관리 시스템인 git을 만들었다.
        git은 git은 기본적으로 커밋을 통해 변경사항을 저장하고 생성된 커밋은 커밋되기 이전 커밋을 참조하고 있어서 변경사항을 통해서 코드의 전체내용을 확인 할수 있다. 아래와 같이 형상 관리 시스템이 발달하였고 최종적으로 분산 버전 관리시스템의 특징으로 인해 채택되었다. 결론적으로 분산 버전 관리시스템을 이용하면 다양한 브런치를 생성하여 병렬적인 협업 즉 하나의 소스코드로 여러가지 버전을 만들고 그 버전에서 팀단위 혹은 개인별로 다양한 버전을 만들수 있다.
            1. 기존 파일을 여러개 만들어서 관리하는 방식
                - 파일을 여러개 만들기 때문에 용량도 크고 어떤 파일이 최신파일인지 와 어떤 파일에서 파생된 버전인지에 대한 정보를 이름으로 유추해야하기 때문에 관리하기도 힘들고 규모가 커질수록 추적도 힘들어진다.
            2. 로컬버전 관리 시스템
                - 기존 방식에서 용량에 대한 문제를 변경사항만 저장하는 식으로 해결하고 변경사항을 추적하면서 최신버전 과 어떤 버전에서 파생되었는지 파악하는게 가능해졌지만 로컬 환경에서만 동작하기 때문에 협업을 진행하면 사용 할수가 없다. 로컬 버전 관리 시스템은 오프라인에서만 쓰는 git과 유사하다.
            3. 중앙집중 버전 관리 시스템
                - 협업을 위해서 로컬 버전 관리 시스템을 하나의 서버에서 동작하도록 하고 파일이력을 제외한 서버에 저장된 최근 스냅샷만을 가져와서 각자 컴퓨터에서 작업을 한뒤에 다시 서버에 commit을 하여 협업이 가능해 졌지만 관련 동작을 할때마다 서버와 통신을 해야하고 서버가 불안정할때에는 협업이 안되는 단점이 있다.
            4. 분산 버전 관리 시스템
                - 분산 버전 관리 시스템은 중앙집중 버전 관리시스템의 느리고 서버에 의존적이라는 단점을 보완하기 위해서 나왔다. 서버에만 전체 데이터가 존재 하는 것이 아니라 해당 분산 버전 관리시스템을 이용하는 모든 컴퓨터에 데이터를 저장하여 서버가 불안정하더라도 브랜치를 생성하고 commit하는 등의 행위를 계속해서 할수 있고 서버와 통신를 매번하는 것이 아니라 속도가 빠른 장점이 있다.
- ## git과 GitHub은 어떻게 다를까요?
    -  git은 분산 버전 관리 시스템이고 github는 git을 공유하기 위한 원격 저장소 역할을 한다.
- ## git의 clone/add/commit/push/pull/branch/stash 명령은 무엇이며 어떨 때 이용하나요? 그리고 어떻게 사용하나요?
    - ### clone
        
        원격 저장소에 있는 코드를 로컬 컴퓨터로 복사해 오는 것으로 git clone [해당repo의 url주소] 명령어를 입력했을때 현재 위치한 디렉토리에 repo 이름으로 폴더를 만들고 그 안에 코드를 복사 한다. 만약에 뒤에 .을 붙일 경우 현재 디렉토리에 폴더를 만들지 않고 바로 복사한다.
        
    - ### add
        
        변경사항을 staging area로 이동하여 commit 대기 상태로 들어간다. commit을 하기전에 staging area로 올릴때 사용한다. git 폴더 내부 적으로는 index파일에 변경사항 과 파일명을 추가한다. 이때 해당 파일의 변경사항은 .git/objects 내부에 sha-1 해쉬 함수로 변환된 해쉬값이 앞에 두자리는 폴더 이름으로 하고 나머지는 폴더 내부의 파일로 생성된다. 만약에 서로 다른 두 파일이 같은 내용일 경우에는 같은 object를 공유한다.  git add 파일명을 할 경우에는 해당 파일을 staging area로 올리고 git add .를 할경우에는 변경된 모든 파일을 stage로 올린다. 
        
    - ### commit
        
        현재 staging area로 올라와 있는 변경사항을 묶어서 하나의 snapshot을 만든다. 의미있는 작업단위가 변경/추가 되었을때 해당 작업상태를 저장할때 사용한다. git commit을 할경우 터미널에서 vim 에디터가 실행되고 i를 눌러서 insert모드로 들어가고 commit 메세지를 작성한 뒤에 esc를 누르고 :wq를 이용해서 저장하고 나오면 된다. commit -m [commit 메세지]를 입력하면 vim 에디터를 거치지않고 바로 commit 할수 있다. 또한 commit -am [commit 메세지]를 이용하면 현재 추적되고 있는 파일(한번이라도 add를 통해 staging area로 올라온적 있는 파일)을 staging area에 있든 없든 상관없이 바로 commit이 가능하다.
        
    - ### push
        
        현재 로컬환경에서 작업중인 브랜치를 원격 저장소로 올리는 명령어이다. 자신이 변경/추가 한 코드를 다른사람과 공 git push origin branch명을 통해서 원하는 branch를 원격 저장소로 올릴 수 있다. 이때 origin이 원격 저장소롤 뜻한다. 
        
    - ### branch
        
        옵션에 따라서 branch 조회, 생성, 삭제, 이동시키는 명렁어이다. 현재 작업방향에서 다른방향의 작업을 추가하려고 할때 branch를 추가한뒤 추가된 branch에서 작업을 할때 주로 사용한다.  git branch를 통해 기본적으로 현재 존재하는 branch를 조회 할수 있으며 branch명 앞에 * 표시된 것이 현재 작업중인 branch이다.
        git branch 브랜치명을 입력하게 되면 현재 작업중인 commit위치에 입력된 브랜치명의 브랜치를 생성할수 있다. git branch -f 브랜치명 commit주소를 입력하게 되면 해당 commit 주소에 브랜치를 강제로 생성할수 있고 만약에 이미 존재하고 있는 브랜치명이라면 이동되는 것 처럼 동작한다. git branch -d 브랜치명을 하게되면 해당 브랜치를 삭제 할수 있다.
        
    - ### stash
        
        이전 commit 부터 현재 작업중인 변경사항의 처리를 다른곳에 옮길때 사용하는 명령어이다. git stash를 통해 현재까지의 변경사항을  저장하고 git stash pop을 통해서 다시 불러올수 있다. git stash가 쓰이는 이유는 변경사항이 있을때 다른 브런치를 이동하려고 하면 변경사항을 어떤식으로도 처리하라는 경고 메세지가 뜨게 되는데 아직 commit을 하기에는 애매한 그런 상황에서 많이 쓰인다.
        
- ## git의 Object, Commit, Head, Branch, Tag는 어떤 개념일까요? git 시스템은 프로젝트의 히스토리를 어떻게 저장할까요?
    - ### Object
        
        git object는 .git/objects 내부에 존재하는 객체로 key-value형태의 데이터를 저장한다. key는 sha-1 hash알고리즘을 통해서 만들어지고 40글자로 이루어져있으며 앞에 2글자는 폴더로 쓰이고 나머지 38글자는 해당 폴더 내부에 존재한다. value는 데이터를 압축해놓았기 때문에 일반적인 vim에디터를 이용해서 볼수는 없고 git cat-file -p를 통해 내용을 확인할수 있다.  git의 Object에는  4가지 종류가 있다. commit, blob, tree, tags가 있지만 실제 .git 내부를 살펴본 결과 tags는 .git/refs/tags에 존재하는 것을 확인했다. 
        
        - commit
            
            commit 했을 당시 snapshot인 tree와 부모 commit,작성한사람, 커밋한 사람, 커밋메세지의 정보를 가지고 있다.
            
        - blob
            
            blob 객체는 파일의 데이터를 가지고 있다. git의 경우 snapshot 기반으로 정보를 저장하기 때문에 만약에 같은 내용의 파일이 있다면 같은 blob객체를 공유한다. snapshot기반이지만 모든 정보를 다 가지는것이 아니라 가장 최근 snapshot만 가지고 그 이전의 버전을 확인할때에는 각 commit지점마다 데이터의 변경된 값인 delta를 가지고 있어서 최근 snapshot을 기준으로 delta를 적용하여 파일이력을 확인할수 있다.
            
        - tree
            
            tree 객체는 [파일권한 파일타입 hash값 파일명]  이러한 형태의 데이터를 리스트로 가지고 있다. git commit을 할때 생성되는 객체이며 commit객체와의 차이점으로는 commit 객체의 경우 부모 commit과 작성자 등 여러 메타정보들이 같이 들어있지만 tree의 경우에는 commit당시의 파일 상태인 snapshot만을 가지고 있다.
            
        - tags
            
            다른 객체와는 다르게 obeject폴더 내에 있지 않고 refs/tags내부에 존재하고 파일명은 tag의 이름으로 되어있고 그 내부에는 commit 객체의 hash값이 들어있다. 압축되어있지 않아서 vim을 통해서 해당 데이터를 바로 확인할수 있고 git cat-file -p를 통해서 commit 객체를 바로 확인 할수 있다. 
            
    - ### Commit
        
        Commit은 어떤 시점에 이 버전(snapshot)을 남길지 명시적으로 정하는 기준점이다.
        
    - ### Head
        
        현재 작업공간 인 working tree에서 어떤 commit을 기준으로 작업이 일어나는지 알려주는 상대경로값이다. 터미널에서 " ./ "과 의미는 동일하다. HEAD^혹은 HEAD~4이런식으로 이전 커밋의 hash값이나 브런치를 몰라도 HEAD를 통해서 참조가 가능하다.
        
    - ### Branch
        
        branch는 특정 commit의 포인터 역할을 하며 작업 흐름을 나누는 단위이다. 예를 들어서 버전1 브랜치에서 파생하여 버전1-1인 하위 버전의 작업을 추가하고 싶을때 버전1-1브랜치를 생성하여 버전 1에 뿌리를 둔 독립적인 작업흐름을 가져갈수 있다. 
        
    - ### Tag
        
        Tag는 branch와 동일하게 특정 commit의 포인터 역할을 하지만 작업 흐름에 따라 가장 최신 commit을 가르키는 branch와 다르게 tag의 경우 생성당시 가르키고 있는 commit을 기준으로 변하지 않는다. 유의미한 작업단위를 기준으로 commit하는 것에 비해 tag는 배포할수 있을정도의 유의미한 commit에 사용하며 주로 배포버전을 기억하기 위해 쓰인다.
        
    - ### git의 히스토리 저장 방식
        
        git은 commit 객체를 기준으로 히스토리를 저장한다. commit 객체에는 해당 commit의 snapshot과 부모 commit을 가지고 있어서 이를 통해서 체인이 형성되고 commit에 접근하기 위해서 HEAD,Tags,Branch등  commit의 hash값을 참조하는 방식으로 히스토리를 저장한다. 각 브런치의 최근 commit이 snapshot을 가지고 있고 그 이전 commit들은 delta값을 통해서 해당 commit의 snapshot을 확인 할수 있다.
        
- ## 리모트 git 저장소에 원하지 않는 파일이 올라갔을 때 이를 되돌리려면 어떻게 해야 할까요?
    - git reset commit주소를 통해 이전 commit상태로 돌리는 방법이 있고 만약에 중간 지점에 잘못 올라간 파일이 있다면 git rebase -i를 통해서 원치않는 파일이 추가 된 commit을 가장 최신 commit으로 만든 뒤 git commit —amend 명령을 통해 해당 파일을 지운뒤 commit을 하고 다시 git rebase -i 를 통해 원래 순서로 변경해놓는다. rebase -i가 충돌이 난다면 git cherry-pick을 통해 해당 commit을 복사한 뒤 git commit —amend를 통해서 해당 commit을 변경 한뒤에 다음에 변경된 commit들을 git cherry-pick을 통해서 복구한 뒤에 기존에 변경된 comit으로 checkout 한뒤에 git reset을 통해 commit을 제거해 주면 된다.

# 질문사항
- git이 snapshot과 delta를 통해서 commit할 당시의 파일 상태를 관리하는 것으로 이해를 했습니다. 
가장 최근 commit의 snapshot만 가지고 그 이전 commit들은 delta만 가져서 당시 파일 상태를 알수 있다고 하는데 이런 식으로 동작했을때 다음과 같은 상황을 가정해봅니다.
    
    root 브런치로부터 100개의 브런치를 생성한뒤에 각각 한번씩 commit을 한 상황이라면 snapshot을 맨 끝이 아니라 root브런치에 snapshot을 두고 100개의 브런치에 delta를 두는 것이 더 효율적이지 않을까 합니다. 
    
    git 내부적으로 상황에 따라서 이런 최적화가 이루어지는지 궁금해서 질문 남깁니다!