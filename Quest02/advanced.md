# 왜 CSS는 어려울까요?

- css 규칙이 독립적으로 적용되지 않고 부모 요소와 형제 요소의 규칙과 상호작용을 하기때문에 결과값을 쉽게 예측하기 어렵다.
- 브라우저와 os마다 다르게 동작하기 때문에 대응하기 어렵다.
- 네이밍이 글로벌로 잡히기 때문에 네이밍 관리가 힘들다.

# CSS의 어려움을 극복하기 위해 어떤 방법들이 제시되고 나왔을까요?

- bootstrap : 미리 CSS로 만들어놓은 UI 라이브러리인 bootstrap을 사용하여 작성한다.
- Bem 방법론 : 상위 요소 클래스이름__해당 요소 클래스이름 이런식으로 부모 요소의 이름을 가지고와 class명을 지으면 네이밍 관리가 쉽다.
- babel : 하나의 코드를 다양한 브라우저에서 지원할수 있도록 변환해주는 라이브러리인 babel을 사용한다.
- vue.js scope : 컴포넌트마다 css의 스코프를 가지도록 해준다. 원리는 해당 컴포넌트에서 작성된 class에해시값을 붙여서 중복되더라도 해시값으로 구분되도록 해준다.

# CSS가 브라우저에 의해 해석되고 적용되기까지 내부적으로 어떤 과정을 거칠까요?

- html을 파싱한 dom에 css를 파싱한  cssom을 적용하여 최종적으로 렌더링될 렌더트리를 만든뒤 각 요소의 크기와 위치를 계산하는 배치를 한뒤 최종적으로 브라우저에 그려진다. 이때 만약 css가 변경된다면 위치와 크기를 다시 계산하는 리플로우 와 다시 그려지는 리페인팅 과정을 거친다. color,background-color등 위치와 크기와 변하지 않는 값들이 변경되었을때는 리플로우 과정 없이 리페인팅 과정만 거친다. 또한 애니메이션을 적용 할때에는 position : fixed, absolute를 적용하면 주변 요소의 크기와 위치의 영향을 끼치지않고 독립적으로 리플로우가 되기 때문에 성능 최적화에 좋다. 다른 성능 최적화로는 css를 변경하는 것을 매번 적용하는 것이 아니라 queue를 통해 모아 놓았다가 한번에 적용하면 리플로우와 리페인팅이 한번씩만 적용되기때문에 성능에 좋다.

# 웹 폰트의 경우에는 브라우저 엔진 별로 어떤 과정을 통해 렌더링 될까요?
  * IE/Edge : FOIT방식으로 웹폰트를 받아오기전에는 폰트가 적용안된 텍스트를 렌더링 하고 웹폰트의 다운로드가 완료되면 그때 웹폰트가 적용된 폰트를 렌더링 한다.
  * 사파리 : FOUT방식으로 웹폰트를 받아오기전에는 해당 텍스트를 안보여주고 있다가 웹폰트의 다운로드가 완료되면 그때 웹폰트가 적용된 폰트를 렌더링 한다.
  * 파이어폭스/크롬 : FOIT 3s방식으로 기본적으로 FOIT와 동일하게 처음 3초간은 웹폰트가 다운로드 되기전에는 텍스트를 안보여주지만 3초가 넘어가면 FOUT방식으로 기본폰트로 보여준다.