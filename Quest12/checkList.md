# checkList

## 입력 데이터의 Validation을 웹 프론트엔드에서 했더라도 서버에서 또 해야 할까요? 그 이유는 무엇일까요?

api요청이 노출되있기 때문에 스크립트를 작성해서 같은 요청을 보낼수 있기 때문에 프론트엔드의 검증을 거치지 않고 서버에 api를 보낼 수 있다.

### 서버로부터 받은 HTML 내용을 그대로 검증 없이 프론트엔드에 innerHTML 등을 통해 적용하면 어떤 문제점이 있을까요?

악의적인 스크립트를 넣어서 사용자의 쿠키나 로컬스토리지에 있는 값들을 다른 서버로 요청하거나 서버에 특정 api를 보내서 정보를 지우거나 정보를 탈취할 수 있다.

### XSS(Cross-site scripting)이란 어떤 공격기법일까요?

게시판과 같이 사용자의 입력값이 다른 사용자에게도 보여주는 로직에 일반적인 텍스트를 입력하는게 아니라 <script></script>로 감싼 코드를 입력하게 되면 브라우저가 렌더링 될때 script태그안에 있는 코드를 자동적으로 실행시키는 방식으로 다른 사용자의 브라우저에서 원하는 코드를 실행시키는 공격기법이다. 이를 막기 위해서는 사용자의 입력값을 innerHTML을 통해서 렌더링되게 하지말고 innerText와 같은 값으로 코드로 평가되지않고 텍스트로만 평가되도록 렌더링하거나 렌더링하기전에 정규표현식등을 이용해서 입력값에 태그와 같이 코드가 실행될만한 요소가 있는지 검증하는 작업을 넣는다.

### CSRF(Cross-site request forgery)이란 어떤 공격기법일까요?

http 통신에는 상태가 없고 서버는 클라이언트가 인가된 유저인지를 판단할때 쿠키를 사용해서 인식하는 것을 이용한 공격기법으로 사용자 미리 만들어둔 사이트에 들어가면 스크립트가 실행되고 브라우저에 남아있는 쿠키와 함께 요청이 보내지면 서버는 해당 요청을 유저가 요청한 것으로 인식하고 해당 요청을 처리하게하는 공격기법이다. 이를 방지하기 위해 cors 설정에서 origin을 제한하는 방법이있다. delete와 Put같은 안전하지 않은 요청의 경우에는 정식 요청을 보내기전에 preflight 요청을 통해서 해당 브라우저가 허용된 origin인지를 판단한뒤에 요청을 보낸다.

### SQL Injection이란 어떤 공격기법일까요?

서버가 요청 값을 그대로 SQL 쿼리에 넣어서 데이터를 조작할 경우를 특정하여 공격하는 기법으로 대표적으로

특정 id만으로 불러오는 api가 있다고 했을때 `SELECT id,password FROM Users WHERE id = ${id}` 과 같이 id값을 받아서 데이터를 뽑아서 응답하는 로직이라고 했을때 1 Or 1=1 이라는 입력값이 들어왔을때 1=1은 언제나 true이기 때문에 모든 목록을 가져올수도 있고 ; drop table ~ ;과 같이 세미클론을 붙여서 개별적인 명령으로 인식시킨뒤 원하는 쿼리문을 넣는 경우도 있다. 이를 방지하기 위해서는 입력으로 들어온 값에 수상한 문자패턴이 있는지 확인을 한뒤 쿼리문이 실행되도록 해야한다. 이때는 직접 만드는 것보다는 잘 만들어진 프레임워크를 사용하는게 좀더 안전한다.

## 대부분의 최신 브라우저에서는 HTTP 대신 HTTPS가 권장됩니다. 이유가 무엇일까요?

### HTTPS와 TLS는 어떤 식으로 동작하나요? HTTPS는 어떤 역사를 가지고 있나요?

클라이언트와 서버는 본격적인 통신을 하기전에 handShake의 과정을 통해서 hello server, hello client를 통해 서로 랜덤한 값을 주고 받는다. 이때 서버는 ssl 인증서를 같이 보낸다. 클라이언트는 인증서를 통해 서버가 검증된 서버인지를 확인한 뒤에 주고받은 랜덤한 값을 조합하여 Pre-master-key를 서버의 공개키로 암호화하여 서버에 전달되고 그 이후로는 pre-masster-key를 이용한 session-key를 이용한 대칭키 방식의 암호화 통신을 한다.

1. 데이터를 암호화한다.
2. 통신하는 서버가 인증된 서버인지를 확인한다.
3. 데이터의 위변조가 없는지 확인한다.

위에 3가지 이점때문에 http보다는 https방식을 권장하고 구글검색에서도 https가 아닌 사이트는 검색순위에서도 밀려나고 안전하지 않다는 표시가 뜨기 때문에 되도록이면 https방식을 사용해야 한다.

### HTTPS의 서비스 과정에서 인증서는 어떤 역할을 할까요? 인증서는 어떤 체계로 되어 있을까요?

인증서는 검증된 기관인 ca에서 발급을 하며 ca에서는 인증서를 발행할때 ca의 비밀키로 암호화 하여 발행한다.

서버는 발행받은 암호화된 인증서를 클라이언트와 통신을 할때 handShake과정에서 인증서를 넘겨준다.

암호화된 인증서를 받은 클라이언트는 브라우저에 내장되있는 ca의 공개키를 이용해서 인증서를 복호화한다.

인증서에는 서버의 domain과 서버의 공개키, 어떤방식으로 암호화할지에 대한 내용이 들어있다.

클라이언트는 해당 인증서의 domain이 사용자가 의도한 domain과 일치하는지를 확인하는 방식으로 통신을 하려는 서버가 인증된 서버인지를 확인한다.

이때 인증서는 한곳에서만 인증을 하는게 아니라 서버는 중간 인증기관에 인증을 받고 중간 인증기관은 루트 인증기관의 인증을 받는다.

# advanced

## TLS의 인증서에 쓰이는 암호화 알고리즘은 어떤 종류가 있을까요?

1. RSA (Ron Adi Adleman)
2. DSS (Digital Signature Standard)
3. ECDSA (Elliptic Curve Digital Signature Standard)

## HTTP/3은 기존 버전과 어떻게 다를까요? HTTP의 버전 3이 나오게 된 이유는 무엇일까요?

http3는 기존의 tcp기반의 통신방식이 아닌 udp 를 기반으로한 quic방식의 통신방식을 사용한다. 주요한 차이점은 기존의 통신은 핸드쉐이크를 통해 커넥션을 형성하지만 http3는 핸드쉐이크 과정이 없기 때문에 전송 속도가 빠르고 http3는 패킷을 개별적으로 암호화 하고 패킷의 헤더까지 암호화를 하기 때문에 보안적으로 훨씬 안전하다.
